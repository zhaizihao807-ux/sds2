<!doctype html>
<html lang="zh-Hans">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#0b2a1d" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Hand Tree</title>

  <style>
    :root{
      --bg0:#06160f;
      --bg1:#0b2a1d;
      --gold:#c7a54f;
      --gold2:#ffd57a;
      --ui:rgba(8,18,14,.55);
      --ui2:rgba(10,26,19,.70);
      --line:rgba(255,213,122,.22);
      --text:rgba(255,246,230,.92);
      --muted:rgba(255,246,230,.72);
      --shadow: 0 18px 60px rgba(0,0,0,.55);
    }
    *{box-sizing:border-box}
    html,body{
      height:100%; margin:0;
      background:radial-gradient(1200px 700px at 40% 15%, #124332 0%, var(--bg1) 35%, var(--bg0) 85%);
      overflow:hidden; color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "PingFang SC","Noto Sans CJK SC","Microsoft YaHei";
      touch-action:none; user-select:none;
    }
    #app{position:fixed; inset:0;}
    canvas#gl{position:absolute; inset:0; width:100%; height:100%; display:block;}

    #grain{
      pointer-events:none; position:absolute; inset:0;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='260' height='260'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='260' height='260' filter='url(%23n)' opacity='.22'/%3E%3C/svg%3E");
      mix-blend-mode:overlay; opacity:.18;
    }

    #hud{
      position:absolute; left:12px; top:12px;
      width:min(420px, calc(100vw - 24px));
      padding:10px 10px 8px;
      border:1px solid var(--line);
      border-radius:14px;
      background:linear-gradient(180deg, var(--ui2), var(--ui));
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      z-index:10;
    }
    #hud.hidden{ display:none; }

    #hud .top{
      display:flex; align-items:center; gap:8px;
      font-weight:750; letter-spacing:.2px;
    }
    .dot{
      width:9px; height:9px; border-radius:999px;
      background: radial-gradient(circle at 30% 30%, var(--gold2), var(--gold));
      box-shadow: 0 0 12px rgba(255,213,122,.35);
      flex:0 0 auto;
    }
    #badge{
      margin-left:auto;
      padding:6px 10px;
      border-radius:999px;
      font-size:12px;
      border:1px solid rgba(255,213,122,.20);
      background:rgba(0,0,0,.22);
      color:rgba(255,246,230,.88);
      white-space:nowrap;
    }
    #hud .row{
      margin-top:8px;
      display:flex; flex-wrap:wrap; gap:8px; align-items:center;
    }
    .btn{
      cursor:pointer;
      border:1px solid rgba(255,213,122,.26);
      background:linear-gradient(180deg, rgba(199,165,79,.14), rgba(192,22,43,.08));
      color:var(--text);
      padding:9px 10px;
      border-radius:12px;
      font-weight:750;
      letter-spacing:.2px;
      box-shadow: 0 10px 26px rgba(0,0,0,.25);
      transition: transform .12s ease, filter .12s ease;
    }
    .btn:hover{transform: translateY(-1px); filter:brightness(1.05)}
    .btn:active{transform: translateY(0px); filter:brightness(.98)}
    .btn.secondary{
      border-color: rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-weight:700;
      box-shadow:none;
    }
    input[type="file"]{display:none}
    label.file{
      cursor:pointer;
      display:inline-flex; align-items:center; gap:8px;
      padding:9px 10px;
      border-radius:12px;
      border:1px solid rgba(255,213,122,.18);
      background:rgba(255,255,255,.06);
      font-size:12px;
      user-select:none;
    }
    .hint{
      margin-top:8px;
      font-size:12px;
      color:var(--muted);
      line-height:1.4;
    }

    #menuBtn{
      position:absolute; right:12px; top:12px;
      z-index:11;
      width:42px; height:42px;
      border-radius:14px;
      border:1px solid rgba(255,213,122,.20);
      background:rgba(0,0,0,.28);
      color:rgba(255,246,230,.92);
      display:flex; align-items:center; justify-content:center;
      font-size:18px;
      box-shadow: var(--shadow);
      cursor:pointer;
      user-select:none;
    }

    #gate{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      padding:16px;
      background: radial-gradient(900px 500px at 50% 30%, rgba(255,213,122,.07), rgba(0,0,0,.65));
      z-index:9;
    }
    #gate .card{
      width:min(640px, 92vw);
      border-radius:20px;
      padding:16px 16px 14px;
      border:1px solid rgba(255,213,122,.22);
      background:linear-gradient(180deg, rgba(10,26,19,.78), rgba(8,18,14,.58));
      box-shadow: 0 24px 80px rgba(0,0,0,.65);
      backdrop-filter: blur(10px);
    }
    #gate h1{margin:0; font-size:16px}
    #gate p{margin:10px 0 0; font-size:13px; color:var(--muted); line-height:1.55}
    #gate .actions{margin-top:12px; display:flex; gap:10px; flex-wrap:wrap}

    #debugCam{
      position:absolute; right:12px; bottom:12px;
      width:min(320px, 52vw);
      aspect-ratio: 4 / 3;
      border-radius:16px;
      overflow:hidden;
      border:1px solid rgba(255,213,122,.20);
      box-shadow: var(--shadow);
      background: rgba(0,0,0,.25);
      display:none;
      z-index:10;
    }
    #debugCam canvas{width:100%; height:100%; display:block;}

    #bootError{
      position:absolute; inset:0;
      display:none;
      align-items:center; justify-content:center;
      padding:18px;
      background: rgba(0,0,0,.72);
      z-index:999;
    }
    #bootError .card{
      width:min(860px, 94vw);
      border-radius:18px;
      padding:16px 16px 14px;
      border:1px solid rgba(255,213,122,.22);
      background:linear-gradient(180deg, rgba(10,26,19,.90), rgba(8,18,14,.72));
      box-shadow: 0 24px 80px rgba(0,0,0,.65);
    }
    #bootError h2{margin:0; font-size:16px}
    #bootError p{margin:8px 0 0; font-size:13px; color:rgba(255,246,230,.78); line-height:1.55}
    #bootError pre{
      margin:10px 0 0;
      padding:10px;
      border-radius:12px;
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.12);
      color: rgba(255,246,230,.86);
      overflow:auto;
      max-height: 42vh;
      font-size: 12px;
      white-space: pre-wrap;
      word-break: break-word;
    }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
    }
  }
  </script>

  <script src="https://unpkg.com/@mediapipe/drawing_utils@0.3.1675466124/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@mediapipe/hands@0.4.1675469240/hands.js" crossorigin="anonymous"></script>
</head>

<body>
  <div id="app">
    <canvas id="gl"></canvas>
    <div id="grain"></div>

    <div id="menuBtn" title="ÊâìÂºÄËèúÂçï">‚ò∞</div>

    <div id="hud">
      <div class="top">
        <span class="dot"></span>
        <div>ÊâãÂäøÂú£ËØûÊ†ë</div>
        <div id="badge">S:CONE ¬∑ G:‚Äî ¬∑ CAM:OFF ¬∑ P:0</div>
      </div>

      <div class="row">
        <button class="btn" id="startBtn">ÂºÄÂßã(ÊëÑÂÉèÂ§¥)</button>
        <button class="btn secondary" id="watchBtn">‰ªÖËßÇÁúã(ÊâãÂä®ÊóãËΩ¨)</button>

        <label class="file" for="photosInput">‰∏ä‰º†
          <input id="photosInput" type="file" accept="image/*" multiple />
        </label>

        <button class="btn secondary" id="toggleDebug">Ë∞ÉËØï</button>
        <button class="btn secondary" id="hideHudBtn">Êî∂Ëµ∑</button>
      </div>

      <div class="hint">Êè°Êã≥=ÂêàÊã¢ÔΩúÂº†ÂºÄ=Êï£ÂºÄÔΩúÊçèÂêà=ÊîæÂ§ßÔΩúÊï£ÂºÄÊó∂ËΩ¨ÊâãÊéå=ÊóãËΩ¨ËßÜËßíÔºà‰ªÖËßÇÁúãÂèØÊâãÊåáÊãñÂä®ÊóãËΩ¨/ÂèåÊåáÁº©ÊîæÔºâ</div>
    </div>

    <div id="debugCam"><canvas id="debug2d"></canvas></div>

    <div id="gate">
      <div class="card">
        <h1>üéÑ Áî®ÊâãÂäøÊéßÂà∂Âú£ËØûÊ†ë</h1>
        <p>
          ÈªòËÆ§Âä†ËΩΩÂêåÁõÆÂΩï <b>pic1.jpg ~ pic20.jpg</b>„ÄÇ<br/>
          ‚Äú‰ªÖËßÇÁúã‚ÄùÊ®°ÂºèÔºöÂçïÊåáÊãñÂä®ÊóãËΩ¨ËßÜËßíÔºåÂèåÊåáÊçèÂêàÁº©ÊîæÔºåÁÇπÂáªÁÖßÁâáÊîæÂ§ß/ÈÄÄÂá∫„ÄÇ
        </p>
        <div class="actions">
          <button class="btn" id="gateStart">ÂºÄÂßã(ÊëÑÂÉèÂ§¥)</button>
          <button class="btn secondary" id="gateNoCam">‰ªÖËßÇÁúã(ÊâãÂä®ÊóãËΩ¨)</button>
        </div>
      </div>
    </div>

    <div id="bootError">
      <div class="card">
        <h2>Âä†ËΩΩÂ§±Ë¥•</h2>
        <p id="bootErrorMsg"></p>
        <pre id="bootErrorDetail"></pre>
        <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap">
          <button class="btn secondary" onclick="location.reload()">Âà∑Êñ∞ÈáçËØï</button>
        </div>
      </div>
    </div>

    <video id="video" playsinline muted style="display:none"></video>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
    import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";

    const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
    const damp  = (a, b, lambda, dt) => THREE.MathUtils.damp(a, b, lambda, dt);

    const STATE = { CONE:"CONE", SCATTER:"SCATTER", PHOTO:"PHOTO" };
    let state = STATE.CONE;
    let selectedPhoto = null;
    let camState = "OFF";
    let started = false;

    const hud = document.getElementById("hud");
    const badgeEl = document.getElementById("badge");
    const gate = document.getElementById("gate");

    function setBadge(gestureLabel="‚Äî"){
      badgeEl.textContent = `S:${state} ¬∑ G:${gestureLabel} ¬∑ CAM:${camState} ¬∑ P:${photoPlanes.length}`;
    }

    const bootError = document.getElementById("bootError");
    const bootErrorMsg = document.getElementById("bootErrorMsg");
    const bootErrorDetail = document.getElementById("bootErrorDetail");
    function showBootError(msg, detail){
      bootErrorMsg.textContent = msg;
      bootErrorDetail.textContent = detail || "";
      bootError.style.display = "flex";
    }

    function hideHud(){ hud.classList.add("hidden"); }
    function showHud(){ hud.classList.remove("hidden"); }
    document.getElementById("hideHudBtn").addEventListener("click", hideHud);
    document.getElementById("menuBtn").addEventListener("click", ()=>{
      hud.classList.contains("hidden") ? showHud() : hideHud();
    });

    // renderer / scene
    const canvas = document.getElementById("gl");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.78;

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x06160f, 0.052);

    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 120);
    camera.position.set(0, 3.8, 14);

    const key = new THREE.DirectionalLight(0xfff0d5, 0.90);
    key.position.set(6, 10, 6);
    scene.add(key);

    const fill = new THREE.DirectionalLight(0xffd57a, 0.30);
    fill.position.set(-8, 6, -7);
    scene.add(fill);

    const warmPoint = new THREE.PointLight(0xffc86b, 0.95, 45, 2);
    warmPoint.position.set(0, 7, 5);
    scene.add(warmPoint);

    const redGlow = new THREE.PointLight(0xff2a3d, 0.65, 35, 2);
    redGlow.position.set(-4, 2.5, 2);
    scene.add(redGlow);

    const bg = new THREE.Mesh(
      new THREE.SphereGeometry(60, 48, 32),
      new THREE.MeshBasicMaterial({ color: 0x0b2a1d, side: THREE.BackSide, transparent:true, opacity: 0.95 })
    );
    scene.add(bg);

    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));

    const bloom = new UnrealBloomPass(
      new THREE.Vector2(innerWidth, innerHeight),
      0.55, 0.55, 0.28
    );
    composer.addPass(bloom);

    const VignetteGrainShader = {
      uniforms: {
        tDiffuse: { value: null },
        uTime: { value: 0 },
        uVig: { value: 0.40 },
        uGrain: { value: 0.05 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float uTime;
        uniform float uVig;
        uniform float uGrain;
        varying vec2 vUv;

        float hash(vec2 p){
          p = fract(p*vec2(123.34, 345.45));
          p += dot(p, p+34.345);
          return fract(p.x*p.y);
        }
        void main(){
          vec4 col = texture2D(tDiffuse, vUv);
          vec2 d = vUv - 0.5;
          float vig = smoothstep(0.85, 0.15, dot(d,d) * 1.75);
          col.rgb *= mix(1.0 - uVig, 1.0, vig);
          float n = hash(vUv * vec2(1920.0,1080.0) + uTime);
          col.rgb += (n - 0.5) * uGrain;
          gl_FragColor = col;
        }
      `
    };
    const vignettePass = new ShaderPass(VignetteGrainShader);
    composer.addPass(vignettePass);

    const floor = new THREE.Mesh(
      new THREE.CircleGeometry(9.5, 64),
      new THREE.MeshStandardMaterial({
        color: 0x0b2a1d,
        metalness: 0.10,
        roughness: 0.92,
        emissive: 0x07140f,
        emissiveIntensity: 0.18
      })
    );
    floor.rotation.x = -Math.PI/2;
    floor.position.y = -2.2;
    scene.add(floor);

    const ROOT = new THREE.Group();
    scene.add(ROOT);

    const TREE = { height: 9.2, radius: 4.2, baseY: -2.0 };

    function conePose(i, n, jitter=0.26){
      const t = i / Math.max(1, n-1);
      const y = TREE.baseY + t * TREE.height;
      const r = (1.0 - t) * TREE.radius;
      const angle = i * 0.62 + t * 5.2;
      const x = Math.cos(angle) * r;
      const z = Math.sin(angle) * r;
      const jx = (Math.sin(i*12.9898)*43758.5453)%1 * jitter - jitter/2;
      const jz = (Math.sin(i*78.233)*  9623.673)%1 * jitter - jitter/2;
      return new THREE.Vector3(x + jx, y, z + jz);
    }
    function randomInShell(rMin, rMax){
      const u = Math.random(), v = Math.random();
      const theta = 2*Math.PI*u;
      const phi = Math.acos(2*v - 1);
      const r = THREE.MathUtils.lerp(rMin, rMax, Math.random());
      return new THREE.Vector3(
        r*Math.sin(phi)*Math.cos(theta),
        r*Math.cos(phi),
        r*Math.sin(phi)*Math.sin(theta)
      );
    }

    function makeStripeTexture(){
      const c = document.createElement("canvas");
      c.width = 128; c.height = 32;
      const g = c.getContext("2d");
      g.fillStyle = "#f7f1e6"; g.fillRect(0,0,c.width,c.height);
      g.fillStyle = "#c0162b";
      for(let x=-64;x<c.width+64;x+=24){
        g.save(); g.translate(x,0);
        g.beginPath();
        g.moveTo(0,0); g.lineTo(14,0); g.lineTo(24,c.height); g.lineTo(10,c.height);
        g.closePath(); g.fill();
        g.restore();
      }
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(2.4, 1);
      return tex;
    }
    const stripeTex = makeStripeTexture();

    const goldMat = new THREE.MeshPhysicalMaterial({
      color: 0xc7a54f, metalness: 0.95, roughness: 0.34,
      clearcoat: 0.55, clearcoatRoughness: 0.28,
      emissive: 0x1a1207, emissiveIntensity: 0.18
    });
    const redMat = new THREE.MeshPhysicalMaterial({
      color: 0xc0162b, metalness: 0.60, roughness: 0.40,
      clearcoat: 0.55, clearcoatRoughness: 0.30,
      emissive: 0x16050a, emissiveIntensity: 0.18
    });
    const greenMat = new THREE.MeshPhysicalMaterial({
      color: 0x1f6b45, metalness: 0.35, roughness: 0.78,
      clearcoat: 0.35, clearcoatRoughness: 0.35,
      emissive: 0x06150f, emissiveIntensity: 0.16
    });
    const caneMat = new THREE.MeshPhysicalMaterial({
      color: 0xffffff, map: stripeTex,
      metalness: 0.05, roughness: 0.28,
      clearcoat: 0.75, clearcoatRoughness: 0.18,
      emissive: 0x120407, emissiveIntensity: 0.10
    });

    function buildInstanced({count, geometry, material, scaleRange=[0.18,0.32], spin=1.0}){
      const mesh = new THREE.InstancedMesh(geometry, material, count);
      mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      mesh.frustumCulled = false;
      ROOT.add(mesh);

      const items = new Array(count).fill(0).map((_,i)=>({
        p: conePose(i,count),
        tp: conePose(i,count),
        q: new THREE.Quaternion(),
        tq: new THREE.Quaternion(),
        s: THREE.MathUtils.lerp(scaleRange[0], scaleRange[1], Math.random()),
        ts: 1,
        seed: Math.random()*1000,
        spin: (Math.random()*2-1)*spin
      }));

      for(const it of items){
        it.ts = it.s;
        it.q.setFromEuler(new THREE.Euler(0, it.seed*0.01, 0));
        it.tq.copy(it.q);
      }
      return { mesh, items, tmpM: new THREE.Matrix4(), tmpV: new THREE.Vector3(), tmpE: new THREE.Euler() };
    }

    const ornamentsGold = buildInstanced({
      count: 220, geometry: new THREE.SphereGeometry(0.35, 16, 12),
      material: goldMat, scaleRange: [0.22, 0.46], spin: 1.0
    });
    const ornamentsRed = buildInstanced({
      count: 140, geometry: new THREE.SphereGeometry(0.32, 16, 12),
      material: redMat, scaleRange: [0.20, 0.42], spin: 1.1
    });
    const cubes = buildInstanced({
      count: 150, geometry: new THREE.BoxGeometry(0.6,0.6,0.6),
      material: greenMat, scaleRange: [0.22, 0.42], spin: 0.8
    });

    function makeCaneGeo(){
      const curve = new THREE.CatmullRomCurve3([
        new THREE.Vector3(0,-0.55,0),
        new THREE.Vector3(0, 0.12,0),
        new THREE.Vector3(0.26,0.42,0),
        new THREE.Vector3(0.48,0.34,0),
        new THREE.Vector3(0.52,0.08,0)
      ]);
      return new THREE.TubeGeometry(curve, 48, 0.10, 10, false);
    }
    const canes = buildInstanced({
      count: 70, geometry: makeCaneGeo(),
      material: caneMat, scaleRange: [0.5, 0.9], spin: 1.2
    });

    function makeStar(){
      const starShape = new THREE.Shape();
      const spikes = 5, outer = 0.62, inner = 0.28;
      for(let i=0;i<spikes*2;i++){
        const a = (i/(spikes*2))*Math.PI*2 - Math.PI/2;
        const r = (i%2===0)? outer : inner;
        starShape.lineTo(Math.cos(a)*r, Math.sin(a)*r);
      }
      starShape.closePath();
      const geo = new THREE.ExtrudeGeometry(starShape, { depth: 0.22, bevelEnabled:true, bevelThickness:0.06, bevelSize:0.04, bevelSegments:2 });
      geo.center();
      const mat = new THREE.MeshPhysicalMaterial({
        color: 0xffd57a, metalness: 1.0, roughness: 0.25,
        emissive: 0xffb84a, emissiveIntensity: 0.65,
        clearcoat: 0.75, clearcoatRoughness: 0.18
      });
      const m = new THREE.Mesh(geo, mat);
      m.position.set(0, TREE.baseY + TREE.height + 0.55, 0);
      m.rotation.y = 0.6;
      return m;
    }
    const star = makeStar();
    ROOT.add(star);

    // sparkle
    const particleCount = 2300;
    const pGeo = new THREE.BufferGeometry();
    const pPos = new Float32Array(particleCount*3);
    const pSeed = new Float32Array(particleCount);
    for(let i=0;i<particleCount;i++){
      const p = conePose(i, particleCount, 0.85);
      pPos[i*3+0] = p.x;
      pPos[i*3+1] = p.y;
      pPos[i*3+2] = p.z;
      pSeed[i] = Math.random();
    }
    pGeo.setAttribute("position", new THREE.BufferAttribute(pPos, 3));
    pGeo.setAttribute("aSeed", new THREE.BufferAttribute(pSeed, 1));

    const pMat = new THREE.ShaderMaterial({
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      uniforms: { uTime:{value:0} },
      vertexShader: `
        attribute float aSeed;
        uniform float uTime;
        varying float vSeed;
        varying float vTw;
        void main(){
          vSeed = aSeed;
          vec3 pos = position;
          float t = uTime*0.85 + aSeed*12.0;
          float wob = 0.02 + 0.05 * aSeed;
          pos.x += sin(t*1.7) * wob;
          pos.z += cos(t*1.5) * wob;
          pos.y += sin(t*1.1) * wob * 0.6;
          vec4 mv = modelViewMatrix * vec4(pos, 1.0);
          gl_Position = projectionMatrix * mv;
          float tw = 0.45 + 0.55 * sin(t*2.2);
          vTw = tw;
          float size = mix(1.5, 7.5, tw);
          size *= (300.0 / -mv.z);
          gl_PointSize = clamp(size, 1.0, 34.0);
        }
      `,
      fragmentShader: `
        precision highp float;
        varying float vSeed;
        varying float vTw;
        void main(){
          vec2 uv = gl_PointCoord - 0.5;
          float d = length(uv);
          float core = smoothstep(0.26, 0.0, d);
          float halo = smoothstep(0.50, 0.20, d) * 0.35;
          vec3 gold = vec3(1.00, 0.84, 0.48);
          vec3 red  = vec3(0.96, 0.16, 0.26);
          vec3 grn  = vec3(0.18, 0.78, 0.44);
          float sel = fract(vSeed*7.13);
          vec3 c = (sel < 0.55) ? gold : ((sel < 0.78) ? red : grn);
          float a = (core + halo) * (0.32 + 0.50*vTw);
          gl_FragColor = vec4(c * a, a);
        }
      `
    });
    const sparkle = new THREE.Points(pGeo, pMat);
    ROOT.add(sparkle);

    // photos
    const photoGroup = new THREE.Group();
    ROOT.add(photoGroup);

    const photoPlanes = [];
    const photoRay = new THREE.Raycaster();
    const photoNDC = new THREE.Vector2();

    // ‚úÖ pic1.jpg ~ pic20.jpgÔºàÂêåÁõÆÂΩïÔºâ
    const BASE = new URL(".", location.href);
    const DEFAULT_PHOTO_URLS = Array.from({length:20}, (_,i)=>new URL(`pic${i+1}.jpg`, BASE).toString());

    function makeProceduralPhoto(i){
      const c = document.createElement("canvas");
      c.width = 512; c.height = 640;
      const g = c.getContext("2d");
      const grad = g.createLinearGradient(0,0,512,640);
      grad.addColorStop(0, "#0b2a1d");
      grad.addColorStop(1, "#1f6b45");
      g.fillStyle = grad;
      g.fillRect(0,0,512,640);
      g.globalCompositeOperation = "screen";
      for(let k=0;k<12;k++){
        const x = Math.random()*512, y = Math.random()*640;
        const r = 40 + Math.random()*110;
        const a = 0.05 + Math.random()*0.10;
        g.fillStyle = `rgba(255,213,122,${a})`;
        g.beginPath(); g.arc(x,y,r,0,Math.PI*2); g.fill();
      }
      g.globalCompositeOperation = "source-over";
      for(let k=0;k<130;k++){
        const x = Math.random()*512, y = Math.random()*640;
        const s = Math.random()*2.2;
        g.fillStyle = `rgba(255,246,230,${0.15+Math.random()*0.35})`;
        g.beginPath(); g.arc(x,y,s,0,Math.PI*2); g.fill();
      }
      g.fillStyle = "rgba(255,246,230,.88)";
      g.font = "700 36px system-ui, -apple-system, Segoe UI, sans-serif";
      g.fillText("Merry", 28, 64);
      g.fillText("Christmas", 28, 108);
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }

    // ‚úÖ Èôç‰ΩéËøáÊõùÈ£éÈô©ÔºöËá™ÂèëÂÖâÂº∫Â∫¶Êõ¥ÂÖãÂà∂
    const PHOTO_EMISSIVE = 0.75;

    function addPhotoTexture(tex){
      const aspect = 4/5;
      const w = 1.25;
      const h = w / aspect;

      const geo = new THREE.PlaneGeometry(w, h);
      const mat = new THREE.MeshPhysicalMaterial({
        map: tex,
        roughness: 0.18,
        metalness: 0.0,
        clearcoat: 0.75,
        clearcoatRoughness: 0.10,
        emissive: new THREE.Color(0xffffff),
        emissiveMap: tex,
        emissiveIntensity: PHOTO_EMISSIVE
      });

      const m = new THREE.Mesh(geo, mat);
      m.frustumCulled = false;

      const idx = photoPlanes.length;
      const coneP = conePose(idx, 28, 0.45);
      const scatterP = randomInShell(2.7, 9.5);
      scatterP.y = THREE.MathUtils.clamp(scatterP.y, -1.2, 6.5);

      const item = {
        mesh: m,
        p: coneP.clone(),
        tp: coneP.clone(),
        s: 1.0,
        ts: 1.0,
        coneP,
        scatterP
      };

      m.position.copy(item.p);
      m.lookAt(0, item.p.y, 0);

      photoPlanes.push(item);
      photoGroup.add(m);
      setBadge(hand?.gesture || "‚Äî");
      return item;
    }

    async function loadTextureFromUrl(url){
      return await new Promise((resolve, reject)=>{
        const loader = new THREE.TextureLoader();
        loader.load(url, (t)=>{
          t.colorSpace = THREE.SRGBColorSpace;
          resolve(t);
        }, undefined, reject);
      });
    }

    async function preloadDefaultPhotos(){
      const holders = [];
      for(let i=0;i<DEFAULT_PHOTO_URLS.length;i++){
        holders.push(addPhotoTexture(makeProceduralPhoto(i)));
      }
      for(let i=0;i<DEFAULT_PHOTO_URLS.length;i++){
        try{
          const tex = await loadTextureFromUrl(DEFAULT_PHOTO_URLS[i]);
          const mat = holders[i].mesh.material;
          mat.map = tex;
          mat.emissiveMap = tex;
          mat.needsUpdate = true;
        }catch{}
      }
    }

    const photosInput = document.getElementById("photosInput");
    photosInput.addEventListener("change", async (e)=>{
      const files = [...(e.target.files||[])].slice(0, 30);
      if(!files.length) return;
      for(const f of files){
        const url = URL.createObjectURL(f);
        try{
          const tex = await loadTextureFromUrl(url);
          addPhotoTexture(tex);
        }catch{}
      }
      photosInput.value = "";
      retargetAll();
    });

    function resize(){
      const w = innerWidth, h = innerHeight;
      renderer.setSize(w,h);
      composer.setSize(w,h);
      bloom.setSize(w,h);
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
    }
    addEventListener("resize", resize);

    function setState(next, opts={}){
      state = next;
      if(state !== STATE.PHOTO) selectedPhoto = null;
      if(opts.photo) selectedPhoto = opts.photo;
      retargetAll();
    }

    function retargetAll(){
      const packs = [ornamentsGold, ornamentsRed, cubes, canes];
      for(const pack of packs){
        const items = pack.items;
        for(let i=0;i<items.length;i++){
          const it = items[i];
          if(state === STATE.CONE){
            it.tp.copy(conePose(i, items.length));
          }else{
            const r = 3.2 + (it.seed % 1) * 8.8;
            const ang = (it.seed*1.618) % (Math.PI*2);
            const y = THREE.MathUtils.lerp(-1.6, 6.8, ((Math.sin(it.seed*2.3)+1)*0.5));
            it.tp.set(Math.cos(ang)*r, y, Math.sin(ang)*r);
          }
          pack.tmpE.set(
            ((it.seed*13.1)%1)*Math.PI*2,
            ((it.seed*9.7)%1)*Math.PI*2,
            ((it.seed*7.3)%1)*Math.PI*2
          );
          it.tq.setFromEuler(pack.tmpE);
        }
      }

      for(const ph of photoPlanes){
        if(state === STATE.CONE){
          ph.tp.copy(ph.coneP);
          ph.ts = 0.92;
        }else{
          ph.tp.copy(ph.scatterP);
          ph.ts = 1.0;
        }
      }
    }

    const orbit = { theta: 0, phi: 1.12, r: 14, tTheta: 0, tPhi: 1.12, tR: 14 };
    function updateCamera(dt){
      orbit.theta = damp(orbit.theta, orbit.tTheta, 9, dt);
      orbit.phi   = damp(orbit.phi,   orbit.tPhi,   9, dt);
      orbit.r     = damp(orbit.r,     orbit.tR,     8, dt);
      orbit.phi = clamp(orbit.phi, 0.35, 1.45);
      orbit.r   = clamp(orbit.r, 10.5, 18.5);

      const x = orbit.r * Math.cos(orbit.theta) * Math.sin(orbit.phi);
      const z = orbit.r * Math.sin(orbit.theta) * Math.sin(orbit.phi);
      const y = orbit.r * Math.cos(orbit.phi) + 0.8;
      camera.position.set(x, y, z);
      camera.lookAt(0, 1.6, 0);
    }

    // ====== ‰ªÖËßÇÁúãÔºöÊâãÂä®ÊóãËΩ¨ÔºàÂçïÊåá/Èº†Ê†áÔºâ+ ÂèåÊåáÁº©Êîæ ======
    const pointers = new Map();
    let lastPinchDist = null;

    function getPinchDist(){
      const arr = [...pointers.values()];
      if(arr.length < 2) return null;
      const dx = arr[0].x - arr[1].x;
      const dy = arr[0].y - arr[1].y;
      return Math.hypot(dx, dy);
    }
    function normPointer(e){ return { x: e.clientX, y: e.clientY }; }

    addEventListener("pointerdown", (e)=>{
      try{ e.target.setPointerCapture(e.pointerId); }catch{}
      pointers.set(e.pointerId, normPointer(e));
      if(pointers.size === 2){
        lastPinchDist = getPinchDist();
      }
    }, {passive:true});

    addEventListener("pointermove", (e)=>{
      if(!pointers.has(e.pointerId)) return;
      const prev = pointers.get(e.pointerId);
      const cur  = normPointer(e);
      pointers.set(e.pointerId, cur);

      // ÂçïÊåáÔºöÊóãËΩ¨
      if(pointers.size === 1){
        const dx = cur.x - prev.x;
        const dy = cur.y - prev.y;

        // ÊëÑÂÉèÂ§¥ ON Êó∂ÈÅøÂÖçÂíåÊâãÂäøÊä¢ÊéßÂà∂Ôºõ‰ªÖËßÇÁúã/ÊëÑÂÉèÂ§¥ÂÖ≥Èó≠Êó∂ÂêØÁî®ÊâãÂä®
        if(camState !== "ON"){
          orbit.tTheta -= dx * 0.0052;
          orbit.tPhi   -= dy * 0.0052;
          orbit.tPhi = clamp(orbit.tPhi, 0.40, 1.35);
        }
      }

      // ÂèåÊåáÔºöÁº©Êîæ
      if(pointers.size >= 2){
        const d = getPinchDist();
        if(d && lastPinchDist && camState !== "ON"){
          const ratio = d / lastPinchDist;
          orbit.tR /= ratio;
          orbit.tR = clamp(orbit.tR, 10.5, 18.5);
        }
        lastPinchDist = d;
      }
    }, {passive:true});

    addEventListener("pointerup", (e)=>{
      pointers.delete(e.pointerId);
      if(pointers.size < 2) lastPinchDist = null;
    }, {passive:true});

    addEventListener("pointercancel", (e)=>{
      pointers.delete(e.pointerId);
      if(pointers.size < 2) lastPinchDist = null;
    }, {passive:true});

    // mediapipe
    const video = document.getElementById("video");
    const debugWrap = document.getElementById("debugCam");
    const debugCanvas = document.getElementById("debug2d");
    const dbg = debugCanvas.getContext("2d");

    let mpHands = null;
    let debugOn = false;
    document.getElementById("toggleDebug").addEventListener("click", ()=>{
      debugOn = !debugOn;
      debugWrap.style.display = debugOn ? "block" : "none";
    });

    const hand = {
      present:false, handedness:"Right", lm:null,
      palm:{x:.5,y:.5}, roll:0,
      pinch:false, pinchDown:false, pinchUp:false,
      gesture:"‚Äî",
      _lastPinch:false,
      _rollPrev:null
    };

    const lmGet = (i)=>hand.lm?.[i] || null;
    const dist2 = (a,b)=>Math.hypot(a.x-b.x, a.y-b.y);
    function fingerExtended(tip, pip){ return tip.y < pip.y - 0.02; }

    // Êõ¥ÂÆπÊòìÊçèÂêà
    const PINCH_T = 0.56;

    function detectGesture(){
      const lm = hand.lm;
      if(!lm) return "‚Äî";

      const thumbTip = lm[4], thumbIp = lm[3];
      const idxTip = lm[8], idxPip = lm[6];
      const midTip = lm[12], midPip = lm[10];
      const ringTip = lm[16], ringPip = lm[14];
      const pkyTip = lm[20], pkyPip = lm[18];

      const iEx = fingerExtended(idxTip, idxPip);
      const mEx = fingerExtended(midTip, midPip);
      const rEx = fingerExtended(ringTip, ringPip);
      const pEx = fingerExtended(pkyTip, pkyPip);

      const isRight = (hand.handedness || "Right") === "Right";
      const tEx = isRight ? (thumbTip.x > thumbIp.x + 0.015) : (thumbTip.x < thumbIp.x - 0.015);

      const allOpen = iEx && mEx && rEx && pEx && tEx;
      const allClosed = !iEx && !mEx && !rEx && !pEx && !tEx;

      const wrist = lm[0];
      const midMcp = lm[9];
      const handSize = Math.max(0.001, dist2(wrist, midMcp));
      const pinchD = dist2(thumbTip, idxTip);

      const pinch = pinchD < handSize * PINCH_T;

      hand.pinch = pinch;
      hand.pinchDown = (!hand._lastPinch && pinch);
      hand.pinchUp = (hand._lastPinch && !pinch);
      hand._lastPinch = pinch;

      if(pinch) return "PINCH";
      if(allOpen) return "PALM";
      if(allClosed) return "FIST";
      return "MOVE";
    }

    const gestureDebounce = { cur:"‚Äî", cand:"‚Äî", t:0, hold:0.12 };
    function updateDebouncedGesture(next, dt){
      if(next === gestureDebounce.cur){
        gestureDebounce.cand = next; gestureDebounce.t = 0; return gestureDebounce.cur;
      }
      if(next !== gestureDebounce.cand){
        gestureDebounce.cand = next; gestureDebounce.t = 0;
      }else{
        gestureDebounce.t += dt;
        if(gestureDebounce.t >= gestureDebounce.hold){
          gestureDebounce.cur = gestureDebounce.cand;
          gestureDebounce.t = 0;
        }
      }
      return gestureDebounce.cur;
    }

    function onResults(results){
      hand.present = !!(results.multiHandLandmarks && results.multiHandLandmarks.length);
      if(!hand.present){ hand.lm = null; return; }
      hand.lm = results.multiHandLandmarks[0];
      hand.handedness = results.multiHandedness?.[0]?.label || "Right";

      const w = hand.lm[0], i = hand.lm[5], p = hand.lm[17];
      hand.palm.x = (w.x + i.x + p.x) / 3;
      hand.palm.y = (w.y + i.y + p.y) / 3;

      const dx = i.x - p.x;
      const dy = i.y - p.y;
      hand.roll = Math.atan2(dy, dx);

      if(debugOn){
        const iw = results.image?.width || 640;
        const ih = results.image?.height || 480;
        debugCanvas.width = iw; debugCanvas.height = ih;
        dbg.clearRect(0,0,iw,ih);
        dbg.drawImage(results.image, 0,0,iw,ih);
        drawConnectors(dbg, hand.lm, HAND_CONNECTIONS, {color:"#ffd57a", lineWidth:3});
        drawLandmarks(dbg, hand.lm, {color:"#c0162b", lineWidth:1, radius:2});
      }
    }

    let frameBusy = false;
    function startHandLoop(){
      const loop = async ()=>{
        if(!mpHands) return;
        if(video.readyState >= 2 && !frameBusy){
          frameBusy = true;
          try{ await mpHands.send({ image: video }); }catch{}
          frameBusy = false;
        }
        requestAnimationFrame(loop);
      };
      requestAnimationFrame(loop);
    }

    async function initMediaPipe(){
      if(typeof Hands === "undefined"){
        camState = "ERR"; setBadge(hand?.gesture || "‚Äî");
        showBootError("MediaPipe Êú™Âä†ËΩΩÊàêÂäü", "Hands ÂÖ®Â±ÄÂØπË±°‰∏çÂ≠òÂú®ÔºàÂèØËÉΩ CDN Ë¢´Êã¶ÊàñÁΩëÁªúÈóÆÈ¢òÔºâ„ÄÇ");
        return;
      }
      mpHands = new Hands({
        locateFile: (file) => `https://unpkg.com/@mediapipe/hands@0.4.1675469240/${file}`
      });
      mpHands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.72,
        minTrackingConfidence: 0.72
      });
      mpHands.onResults(onResults);
      startHandLoop();
    }

    function raycastPhotoFromHand(){
      const tip = lmGet(8);
      if(!tip) return null;
      photoNDC.set(tip.x*2-1, -(tip.y*2-1));
      photoRay.setFromCamera(photoNDC, camera);
      const hits = photoRay.intersectObjects(photoPlanes.map(p=>p.mesh), false);
      if(!hits.length) return null;
      const hitMesh = hits[0].object;
      return photoPlanes.find(p=>p.mesh === hitMesh) || null;
    }

    // ÁÇπÂáªÁÖßÁâáÊîæÂ§ßÔºà‰∏§ÁßçÊ®°ÂºèÈÉΩÂèØÁî®Ôºâ
    addEventListener("pointerdown", (e)=>{
      if(!photoPlanes.length) return;
      photoNDC.set((e.clientX/innerWidth)*2-1, -(e.clientY/innerHeight)*2+1);
      photoRay.setFromCamera(photoNDC, camera);
      const hits = photoRay.intersectObjects(photoPlanes.map(p=>p.mesh), false);
      if(hits.length){
        const ph = photoPlanes.find(p=>p.mesh===hits[0].object);
        if(ph) setState(STATE.PHOTO, {photo: ph});
      }
    });

    addEventListener("keydown", (e)=>{
      if(e.key === "1") setState(STATE.CONE);
      if(e.key === "2") setState(STATE.SCATTER);
      if(e.key === "Escape") setState(STATE.SCATTER);
    });

    const clock = new THREE.Clock();

    function updateInstanced(pack, dt){
      const m = pack.mesh;
      const items = pack.items;
      const tmpM = pack.tmpM;
      const tmpV = pack.tmpV;

      for(let i=0;i<items.length;i++){
        const it = items[i];

        if(state !== STATE.CONE){
          const t = clock.elapsedTime*0.55 + it.seed;
          it.tp.x += Math.sin(t*0.9) * 0.0018;
          it.tp.z += Math.cos(t*0.8) * 0.0018;
          it.tp.y += Math.sin(t*0.6) * 0.0012;
        }

        it.p.lerp(it.tp, 1 - Math.exp(-dt*8.5));
        it.q.slerp(it.tq, 1 - Math.exp(-dt*7.0));

        const spin = it.spin * dt * 0.7;
        const dq = new THREE.Quaternion().setFromEuler(new THREE.Euler(spin*0.5, spin, spin*0.35));
        it.q.multiply(dq);

        tmpM.compose(it.p, it.q, tmpV.setScalar(it.s));
        m.setMatrixAt(i, tmpM);
      }
      m.instanceMatrix.needsUpdate = true;
    }

    function facePhotos(dt){
      for(const ph of photoPlanes){
        if(state === STATE.CONE){
          ph.tp.copy(ph.coneP);
          ph.ts = 0.92;
        }else if(state === STATE.SCATTER){
          ph.tp.copy(ph.scatterP);
          ph.ts = 1.0;
        }else if(state === STATE.PHOTO){
          if(ph === selectedPhoto){
            const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
            ph.tp.copy(camera.position.clone().add(fwd.multiplyScalar(3.2)));
            ph.ts = 2.25;
          }else{
            ph.tp.copy(ph.scatterP);
            ph.ts = 0.92;
          }
        }

        ph.p.lerp(ph.tp, 1 - Math.exp(-dt*8.0));
        ph.s = damp(ph.s, ph.ts, 9, dt);

        ph.mesh.position.copy(ph.p);
        ph.mesh.scale.setScalar(ph.s);

        if(state === STATE.CONE){
          const outward = ph.p.clone().setY(ph.p.y).normalize();
          const look = ph.p.clone().add(outward);
          ph.mesh.lookAt(look.x, ph.p.y, look.z);
        }else{
          ph.mesh.lookAt(camera.position);
        }

        // ÊÅíÂÆö‰∫ÆÂ∫¶ÔºàÊîæÂ§ß‰∏çÈ¢ùÂ§ñÂä†‰∫ÆÔºâ
        const mat = ph.mesh.material;
        if(mat) mat.emissiveIntensity = PHOTO_EMISSIVE;
      }
    }

    function updateStar(dt){
      star.rotation.y += dt * 0.40;
      const breathe = 0.93 + 0.07*Math.sin(clock.elapsedTime*1.9);
      star.scale.setScalar(breathe);
    }

    function updateSparkle(){
      pMat.uniforms.uTime.value = clock.elapsedTime;
      vignettePass.uniforms.uTime.value = clock.elapsedTime * 0.75;
    }

    function updateGestures(dt){
      if(!hand.present || !hand.lm){
        hand.gesture = "‚Äî";
        setBadge(hand.gesture);
        return;
      }

      const raw = detectGesture();
      const g = updateDebouncedGesture(raw, dt);
      hand.gesture = g;
      setBadge(hand.gesture);

      if(g === "FIST"){
        if(state !== STATE.CONE) setState(STATE.CONE);
      }else if(g === "PALM"){
        if(state !== STATE.SCATTER) setState(STATE.SCATTER);
      }

      if(hand.pinchDown){
        const ph = raycastPhotoFromHand();
        if(ph) setState(STATE.PHOTO, {photo: ph});
      }
      if(hand.pinchUp){
        if(state === STATE.PHOTO) setState(STATE.SCATTER);
      }

      if(state !== STATE.CONE){
        orbit.tPhi = 0.85 + (0.5 - hand.palm.y) * 0.95;
        orbit.tPhi = clamp(orbit.tPhi, 0.4, 1.35);

        if(hand._rollPrev == null) hand._rollPrev = hand.roll;
        let dRoll = hand.roll - hand._rollPrev;
        if(dRoll > Math.PI) dRoll -= Math.PI*2;
        if(dRoll < -Math.PI) dRoll += Math.PI*2;
        orbit.tTheta += dRoll * 0.9;
        hand._rollPrev = hand.roll;

        orbit.tR = hand.pinch ? 13.2 : 14.0;
      }else{
        hand._rollPrev = null;
      }
    }

    function tick(){
      const dt = Math.min(0.033, clock.getDelta());

      if(camState === "ON") updateGestures(dt);
      else setBadge("‚Äî");

      updateCamera(dt);

      updateInstanced(ornamentsGold, dt);
      updateInstanced(ornamentsRed, dt);
      updateInstanced(cubes, dt);
      updateInstanced(canes, dt);

      facePhotos(dt);
      updateStar(dt);
      updateSparkle();

      // ‚úÖ ÊîæÂ§ßÁÖßÁâáÊó∂Èôç‰Ωé bloomÔºåÈÅøÂÖçËøáÊõùÊ≥õÁôΩ
      const targetBloom  = (state === STATE.PHOTO) ? 0.22 : 0.55;
      const targetThres  = (state === STATE.PHOTO) ? 0.55 : 0.28;
      bloom.strength  = damp(bloom.strength,  targetBloom, 4.0, dt);
      bloom.threshold = damp(bloom.threshold, targetThres, 4.0, dt);

      composer.render();
      requestAnimationFrame(tick);
    }

    async function ensureStarted(){
      if(started) return;
      await preloadDefaultPhotos();
      retargetAll();
      resize();
      tick();
      started = true;
    }

    async function start(withCamera=true){
      try{
        gate.style.display = "none";
        await ensureStarted();
        hideHud();

        if(withCamera){
          if(!navigator.mediaDevices?.getUserMedia){
            camState = "ERR"; setBadge("‚Äî");
            showBootError("ÊµèËßàÂô®‰∏çÊîØÊåÅÊëÑÂÉèÂ§¥ÊàñÈúÄË¶Å HTTPS", "navigator.mediaDevices.getUserMedia ‰∏çÂ≠òÂú®");
            return;
          }

          camState = "REQ"; setBadge("‚Äî");

          navigator.mediaDevices.getUserMedia({
            video: { facingMode: "user", width: {ideal: 640}, height: {ideal: 480} },
            audio: false
          }).then(async (stream)=>{
            camState = "ON"; setBadge("‚Äî");
            video.srcObject = stream;
            await video.play();
            await initMediaPipe();
          }).catch((err)=>{
            camState = "DENIED"; setBadge("‚Äî");
            showBootError("ÊëÑÂÉèÂ§¥ÊùÉÈôêË¢´ÊãíÁªù/Â§±Ë¥•Ôºà‰ªçÂèØ‰ªÖËßÇÁúãÔºâ", String(err && (err.stack || err.message || err)));
          });
        }else{
          camState = "OFF";
          setBadge("‚Äî");
          setState(STATE.SCATTER); // ‰ªÖËßÇÁúãÔºöÊï£ÂºÄÊõ¥ÈÄÇÂêàÊâãÂä®ËΩ¨
        }
      }catch(e){
        showBootError("ÂêØÂä®Â§±Ë¥•", String(e && (e.stack || e.message || e)));
      }
    }

    document.getElementById("gateStart").addEventListener("click", ()=>start(true));
    document.getElementById("gateNoCam").addEventListener("click", ()=>start(false));
    document.getElementById("startBtn").addEventListener("click", ()=>start(true));
    document.getElementById("watchBtn").addEventListener("click", ()=>start(false));

    setBadge("‚Äî");
  </script>
</body>
</html>
